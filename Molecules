#include "TXLib.h"
#include <cmath>
#include <cstdlib>

const double DT = 0.01;
const int M = 50;

struct Sphere
{
    double x;
    double y;
    double radius;
    int N;
    double vx;
    double vy;
    int r;
    int g;
    int b;
};

void draw(struct Sphere );
void move(struct Sphere* );
void checkCollision(struct Sphere* , int windowx, int windowy);
void collisionTwoSpheres(struct Sphere* , struct Sphere* );
void resolveWallCollision(struct Sphere* , int windowx, int windowy);

void draw(struct Sphere sphere)
    {
    COLORREF OldFillColor = txGetFillColor();
    COLORREF OldColor = txGetColor();

    for (int i = 1; i < sphere.N; i++)
    {
        txSetFillColor(RGB(i * sphere.r / sphere.N, i * sphere.g / sphere.N, i * sphere.b / sphere.N));
        txSetColor    (RGB(i * sphere.r / sphere.N, i * sphere.g / sphere.N, i * sphere.b / sphere.N));
        txCircle(sphere.x, sphere.y, sphere.radius - sphere.radius * i / sphere.N);
    }

    txSetFillColor(OldFillColor);
    txSetColor(OldColor);

}

void move(struct Sphere* sphere)
{
    sphere->x += sphere->vx * DT;
    sphere->y += sphere->vy * DT;
}

void checkCollision(struct Sphere* sphere, int windowx, int windowy)
{

    if ((sphere->x > windowx - sphere->radius) or (sphere->x < sphere->radius))
    {
        sphere->vx = - sphere->vx;
    }

    if ((sphere->y > windowy - sphere->radius) or (sphere->y < sphere->radius))
    {
        sphere->vy = - sphere->vy;
    }
}

bool checkTwoSpheres(struct Sphere* sphere1, struct Sphere* sphere2)
{
    if (sphere1->radius + sphere2->radius > sqrt(pow(sphere1->x - sphere2->x, 2)+ pow(sphere1->y - sphere2->y, 2)))
    {
        return true;
    }
    return false;
}

void collisionTwoSpheres(struct Sphere* sphere1, struct Sphere* sphere2)
{
    float distx = sphere1->x - sphere2->x;
    float disty = sphere1->y - sphere2->y;

    float hypotenuse = sqrt(distx * distx + disty * disty);

    float sin = distx / hypotenuse;
    float cos = disty / hypotenuse;
        if (hypotenuse < sphere1->radius + sphere2->radius)
        {
            float Vn1 = sphere2->vx * sin + sphere2->vy * cos;
      		float Vn2 = sphere1->vx * sin + sphere1->vy * cos;
      		float Vt1 = - sphere2->vx * cos +sphere2->vy * sin;
      		float Vt2 = - sphere1->vx * cos + sphere1->vy * sin;
      		float dt = (sphere2->radius + sphere1->radius - hypotenuse) / (Vn1 - Vn2);

      		if (dt > 0.5)
      		{
                dt = 0.5;
            }
      		if (dt < - 0.5)
      		{
                dt = - 0.5;
            }
            sphere1->x = sphere1->x - sphere1->vx * dt;
      		sphere1->y = sphere1->y - sphere1->vy * dt;
      		sphere2->x = sphere2->x - sphere2->vx * dt;
      		sphere2->y = sphere2->y - sphere2->vy * dt;

      		distx = sphere1->x - sphere2->x;
      		disty = sphere1->y - sphere2->y;

      		float back = Vn2;
      		Vn2 = Vn1;
      		Vn1 = back;


      		sphere1->vx = Vn2 * sin - Vt2 * cos;
      		sphere1->vy = Vn2 * cos + Vt2 * sin;
      		sphere2->vx = Vn1 * sin - Vt1 * cos;
      		sphere2->vy = Vn1 * cos + Vt1 * sin;
        }

}

void resolveWallCollision(struct Sphere* sphere, int windowx, int windowy)
{
    if (sphere->x < sphere->radius)
    {
        sphere->x += -sphere->x +sphere->radius;
        sphere->vx *= -1;
    }

    if (sphere->x + sphere->radius > windowx)
    {
        sphere->x -= - fabs(windowx - sphere->x) + sphere->radius;
        sphere->vx *= -1;
    }

    if (sphere->y < sphere->radius)
    {
        sphere->y += -sphere->y +sphere->radius;
        sphere->vy *= -1;
    }

    if (sphere->y + sphere->radius > windowy)
    {
        sphere->y -= - fabs(windowy - sphere->y) + sphere->radius;
        sphere->vy *= -1;
    }
}

int main()
{
    int windowx = 1000;
    int windowy = 600;

    struct Sphere particles[M];
    for (int i = 0; i < M; i++)
    {
        particles[i].x = 10 + 14*i;
        particles[i].y = 15 + 7*i;
        particles[i].radius = 5;
        particles[i].N = 100;
        particles[i].vx = 1000;
        particles[i].vy = 20;
        particles[i].r = 255;
        particles[i].g = 0;
        particles[i].b = 255;
    }

    txCreateWindow(windowx, windowy);
    txSetFillColor(RGB(0, 0, 0));

        txClear();

        txBegin();

        for (int i = 0; i < M; i++)
        {
            draw(particles[i]);
        }

        txEnd();

        for (int i = 0; i < M; i++)
        {
            move(&particles[i]);
            checkCollision(&(particles[i]), windowx, windowy);
            resolveWallCollision(&(particles[i]), windowx, windowy);


            if (checkTwoSpheres(&(particles[i]), &(particles[i+1])))
            {
                collisionTwoSpheres(&(particles[i]), &(particles[i+1]));

            }

            if (checkTwoSpheres(&(particles[i]), &(particles[i+2])))
            {
                collisionTwoSpheres(&(particles[i]), &(particles[i+2]));
            }

            if (checkTwoSpheres(&(particles[i+1]), &(particles[i+2])))
            {
                collisionTwoSpheres(&(particles[i+1]), &(particles[i+2]));

            }

            }


    return 0;

}

